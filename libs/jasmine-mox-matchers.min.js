var currentSpec,isJasmine2=/^2/.test(jasmine.version),jasmineV1MoxMatchers,jasmineV2MoxMatchers;beforeEach(function(){currentSpec=this}),function(){function a(){return currentSpec.$injector.get("$rootScope").$new()}function b(a){for(var b=a,c=1;c<arguments.length;c++)b=b.replace(new RegExp("\\{"+(c-1)+"\\}","g"),jasmine.pp(arguments[c]));return b}function c(a,c){var d=Array.prototype.slice.call(arguments,2),e=b.apply(this,d);return p[a]=e,{pass:c,message:e.replace(" {not}",c?" not":"")}}function d(a){return function(){return[a.replace(" {not}",""),a.replace("{not}","not")]}}function e(a){return!!a&&angular.isFunction(a.then)}function f(a){if(!e(a))throw Error(jasmine.pp(a)+" is not a promise")}function g(b,d,e){f(b);var g=jasmine.createSpy("Promise success callback"),h=jasmine.createSpy("Promise failure callback");b.then(g,h),a().$digest();var i="resolved"===e?g:h,j=!1,k="Expected promise to have been "+e+" with "+jasmine.pp(d)+" but it was not "+e+" at all";if(isJasmine2?i.calls.any():i.calls.length){var l=isJasmine2?i.calls.mostRecent().args[0]:i.mostRecentCall.args[0];angular.isFunction(d)?(d(l),j=!0):j=angular.equals(l,d),k="Expected promise {not} to have been "+e+" with "+jasmine.pp(d)+" but was "+e+" with "+jasmine.pp(l)}return c("to"+("resolved"===e?"Resolve":"Reject")+"With",j,k)}function h(){return{compare:function(a){var b=e(a);return c("toBePromise",b,"Expected {0} {not} to be a promise",a)}}}function i(){return{compare:function(b){f(b);var d=jasmine.createSpy("Promise success callback");b.then(d,angular.noop),a().$digest();var e=isJasmine2?d.calls.any():d.calls.length>0,g="Expected promise {not} to have been resolved";return c("toResolve",e,g)}}}function j(){return{compare:function(a,b){return g(a,b,"resolved")}}}function k(){return{compare:function(b){f(b);var d=jasmine.createSpy("Promise failure callback");b.then(angular.noop,d),a().$digest();var e=isJasmine2?d.calls.any():d.calls.length>0;return c("toReject",e,"Expected promise {not} to have been rejected")}}}function l(){return{compare:function(a,b){return g(a,b,"rejected")}}}function m(){function a(a){var b={};return a.replace(/(^\?)/,"").split("&").map(function(a){return a=a.split("="),b[a[0]]=a[1],b})[0]}return{compare:function(b,d,e){var f=a(b.substring(b.indexOf("?"))),g=_.matches(d)(f)&&(!e||_.matches(f)(d));return c("toHaveQueryParams",g,"Expected URI {not} to have params {0}, actual params were {1} in {2}",d,f,b)}}}function n(){return{compare:function(a,b){var d,e,f;return a.isolateScope()?(d={},angular.forEach(a.isolateScope(),function(a,b){"this"!==b&&"$"!==b.charAt(0)&&(d[b]=a)}),e=_.isEqual(_.pick(d,_.keys(b)),b),f="got {1}"):(e=!1,f="the expected element has no isolate scope"),c("toContainIsolateScope",e,"Expected element isolate scope {not} to contain {0} but "+f,b,d)}}}function o(a){var b={};return angular.forEach(a,function(a,c){var e=function(a){return function(){var b=[this.actual].concat(Array.prototype.slice.call(arguments,0)),e=a.apply(this,b);return this.message=d(p[c]),e.pass}};b[c]=e(a().compare)}),b}var p={};jasmineV2MoxMatchers={toBePromise:h,toHaveBeenResolved:i,toResolve:i,toResolveWith:j,toHaveBeenResolvedWith:j,toReject:k,toRejectWith:l,toHaveBeenRejected:k,toHaveBeenRejectedWith:l,toHaveQueryParams:m,toContainIsolateScope:n},jasmineV1MoxMatchers=o(jasmineV2MoxMatchers),beforeEach(function(){isJasmine2?jasmine.addMatchers(jasmineV2MoxMatchers):this.addMatchers(jasmineV1MoxMatchers)})}();